---
layout: archive
title: "From Scratch Implementations"
permalink: /models/
author_profile: true
---

{% include base_path %}

<link rel="stylesheet" href="{{ '/assets/css/models.css' | relative_url }}?v={{ site.time | date: '%s' }}">

<div class="models-page">
  <div class="models-intro">
    <h1>Paper Replication Collection</h1>
    <p>Collection of my re-implementation of seminal AI/ML papers from scratch in PyTorch.</p>
  </div>

  <!-- Search Section -->
  <div class="search-section">
    <div class="search-container">
      <input type="text" id="model-search" placeholder="üîç Search models (e.g., GPT, BERT, GAN, Transformer...)">
    </div>
    
    <!-- Tag Filters -->
    <div class="search-filters">
      <span class="filter-label">Filter by tags:</span>
      <button class="filter-btn active" data-tag="all">All</button>
      <button class="filter-btn" data-tag="nlp">NLP</button>
      <button class="filter-btn" data-tag="vision">Vision</button>
      <button class="filter-btn" data-tag="generative">Generative</button>
      <button class="filter-btn" data-tag="sequential">Sequential</button>
      <button class="filter-btn" data-tag="attention">Attention</button>
      <button class="filter-btn" data-tag="optimization">Optimization</button>
    </div>
    
    <div class="search-results-info">
      <span id="search-results-count"></span>
      <button id="clear-search" style="display: none;">Clear Filters</button>
    </div>
  </div>

  <div class="models-grid" id="models-container">
    {% for post in site.models %}
      <div class="model-wrapper" 
           data-tags="{{ post.tags | join: ',' | downcase }}"
           data-name="{{ post.title }}"
           data-date="{{ post.date | date: '%Y-%m-%d' }}">
        {% include model-card.html %}
      </div>
    {% endfor %}
  </div>

  <!-- Hidden data container for GitHub dates -->
  <script type="application/json" id="models-github-data">
    {{ site.data.models | jsonify }}
  </script>
</div>

<style>
/* Search styles */
.search-section {
    margin: 30px 0;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 8px;
}

.search-container input {
    width: 100%;
    padding: 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 16px;
    margin-bottom: 15px;
}

.search-results-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 14px;
    color: #666;
}

#clear-search {
    background: #dc3545;
    color: white;
    border: none;
    padding: 4px 12px;
    border-radius: 4px;
    cursor: pointer;
}

.model-wrapper {
    display: block;
}

.model-wrapper.hidden {
    display: none !important;
}
</style>

<script>
// Global variable to store all models data
let allModels = [];

document.addEventListener('DOMContentLoaded', function() {
    console.log('üîç Models page loaded - initializing search and filters...');
    
    // Initialize search and filtering functionality
    setTimeout(function() {
        initializeModelFiltering();
    }, 100);
    
    function initializeModelFiltering() {
        const searchInput = document.getElementById('model-search');
        const clearButton = document.getElementById('clear-search');
        const resultsCount = document.getElementById('search-results-count');
        const tagButtons = document.querySelectorAll('.filter-btn[data-tag]');
        
        // Store all models for filtering (make it global)
        allModels = Array.from(document.querySelectorAll('.model-wrapper')).map(wrapper => {
            const tagsStr = wrapper.getAttribute('data-tags') || '';
            return {
                element: wrapper,
                name: wrapper.querySelector('.model-card__title')?.textContent.toLowerCase() || '',
                description: wrapper.querySelector('.model-card__excerpt')?.textContent.toLowerCase() || '',
                tags: tagsStr.split(',').filter(tag => tag.trim()).map(tag => tag.trim())
            };
        });
        
        let currentQuery = '';
        let currentTag = 'all';
        
        updateResultsCount(allModels.length);
        
        // Search input handler
        if (searchInput) {
            searchInput.addEventListener('input', function() {
                currentQuery = this.value.toLowerCase().trim();
                filterModels();
                updateClearButton();
            });
        }
        
        // Tag filter handlers
        tagButtons.forEach(button => {
            button.addEventListener('click', function() {
                // Remove active class from all buttons
                tagButtons.forEach(btn => btn.classList.remove('active'));
                // Add active class to clicked button
                this.classList.add('active');
                
                currentTag = this.getAttribute('data-tag');
                filterModels();
                updateClearButton();
            });
        });
        
        // Clear search handler
        if (clearButton) {
            clearButton.addEventListener('click', function() {
                searchInput.value = '';
                currentQuery = '';
                currentTag = 'all';
                
                // Reset tag filter to "All"
                tagButtons.forEach(btn => btn.classList.remove('active'));
                document.querySelector('.filter-btn[data-tag="all"]')?.classList.add('active');
                
                filterModels();
                updateClearButton();
            });
        }
        
        function filterModels() {
            console.log(`üîç Filtering - Query: "${currentQuery}", Tag: "${currentTag}"`);
            console.log(`üìã Total models available: ${allModels.length}`);
            
            const filteredModels = allModels.filter(model => {
                // Text search filter
                const matchesSearch = !currentQuery || 
                    model.name.includes(currentQuery) || 
                    model.description.includes(currentQuery);
                
                // Tag filter - check auto-generated tags
                const matchesTag = currentTag === 'all' || 
                    (model.tags && model.tags.includes(currentTag));
                
                console.log(`Model: ${model.name.substring(0, 20)}..., Auto-Tags: "${Array.isArray(model.tags) ? model.tags.join(',') : 'No tags'}", MatchesTag: ${matchesTag}, MatchesSearch: ${matchesSearch}`);
                
                return matchesSearch && matchesTag;
            });
            
            // Show/hide models
            allModels.forEach(model => {
                if (filteredModels.includes(model)) {
                    model.element.style.display = 'block';
                    model.element.classList.remove('hidden');
                } else {
                    model.element.style.display = 'none';
                    model.element.classList.add('hidden');
                }
            });
            
            console.log(`‚úÖ Filtered from ${allModels.length} to ${filteredModels.length} models`);
            updateResultsCount(filteredModels.length);
        }
        
        function updateClearButton() {
            if (clearButton) {
                if (currentQuery || currentTag !== 'all') {
                    clearButton.style.display = 'inline-block';
                } else {
                    clearButton.style.display = 'none';
                }
            }
        }
        
        function updateResultsCount(count) {
            if (resultsCount) {
                if (count === allModels.length) {
                    resultsCount.textContent = `Showing all ${count} models`;
                } else {
                    resultsCount.textContent = `Found ${count} model${count !== 1 ? 's' : ''}`;
                }
            }
        }
        
        console.log('‚úÖ Model filtering initialized with', allModels.length, 'models');
        
        // Load GitHub dates and auto-generate tags
        loadGitHubDatesAndTags();
    }
    
    function loadGitHubDatesAndTags() {
        console.log('üìÖ Loading GitHub creation dates and auto-generating tags...');
        
        const githubDataScript = document.getElementById('models-github-data');
        if (!githubDataScript) {
            console.warn('‚ö†Ô∏è No GitHub data found');
            return;
        }
        
        try {
            const githubData = JSON.parse(githubDataScript.textContent);
            console.log('üìä GitHub data loaded:', githubData);
            
            if (!githubData.models) {
                console.warn('‚ö†Ô∏è No models in GitHub data');
                return;
            }
            
            // Create mapping of model names to GitHub dates and auto-generated tags
            const nameToData = {};
            githubData.models.forEach(model => {
                const autoTags = generateAutoTags(model);
                nameToData[model.name] = {
                    githubDate: model.github_date || model.created_date,
                    tags: autoTags
                };
            });
            
            console.log('üìÖ Data mapping created:', nameToData);
            
            // Update model cards and wrapper elements
            let updatedCards = 0;
            document.querySelectorAll('.model-wrapper').forEach(wrapper => {
                const modelName = wrapper.dataset.name;
                if (!modelName) return;
                
                // Find matching GitHub data
                let modelData = null;
                for (const [name, data] of Object.entries(nameToData)) {
                    if (name.toLowerCase().replace(/[^a-z0-9]/g, '') === 
                        modelName.toLowerCase().replace(/[^a-z0-9]/g, '')) {
                        modelData = data;
                        break;
                    }
                }
                
                if (modelData) {
                    // Update wrapper with auto-generated tags
                    wrapper.setAttribute('data-tags', modelData.tags.join(','));
                    console.log(`üè∑Ô∏è Auto-tagged ${modelName}: ${modelData.tags.join(', ')}`);
                    
                    // Add date info to the model card
                    const modelCard = wrapper.querySelector('.model-card');
                    if (modelCard && modelData.githubDate) {
                        let dateElement = modelCard.querySelector('.model-card__date');
                        if (!dateElement) {
                            dateElement = document.createElement('div');
                            dateElement.className = 'model-card__date';
                            
                            // Try to insert before footer, otherwise append at end
                            const footer = modelCard.querySelector('.model-card__footer');
                            try {
                                if (footer && footer.parentNode === modelCard) {
                                    modelCard.insertBefore(dateElement, footer);
                                } else {
                                    modelCard.appendChild(dateElement);
                                }
                            } catch (e) {
                                console.warn('Failed to insert date element, appending instead:', e);
                                modelCard.appendChild(dateElement);
                            }
                        }
                        
                        // Format date nicely
                        const formattedDate = new Date(modelData.githubDate).toLocaleDateString('en-US', {
                            year: 'numeric',
                            month: 'short',
                            day: 'numeric'
                        });
                        
                        dateElement.innerHTML = `<small>üìÖ Created: ${formattedDate}</small>`;
                    }
                    updatedCards++;
                }
            });
            
            console.log(`‚úÖ Updated ${updatedCards} model cards with GitHub dates and auto-tags`);
            
            // Refresh the allModels data to include new tags
            refreshModelData();
            
        } catch (error) {
            console.error('‚ùå Error parsing GitHub data:', error);
        }
    }
    
    function generateAutoTags(model) {
        const content = (model.name + ' ' + model.description + ' ' + (model.readme_content || '')).toLowerCase();
        const tags = [];
        
        console.log(`üè∑Ô∏è Auto-tagging ${model.name}: Content snippet: "${content.substring(0, 100)}..."`);
        
        // NLP/Language Models
        if (content.includes('bert') || content.includes('gpt') || content.includes('llama') || 
            content.includes('language') || content.includes('nlp') || content.includes('text') ||
            content.includes('transformer') || content.includes('lstm') || content.includes('rnn')) {
            tags.push('nlp');
            console.log(`  ‚úÖ Added NLP tag`);
        }
        
        // Computer Vision
        if (content.includes('vision') || content.includes('clip') || content.includes('image') || 
            content.includes('cnn') || content.includes('resnet') || content.includes('vit')) {
            tags.push('vision');
            console.log(`  ‚úÖ Added Vision tag`);
        }
        
        // Generative Models
        if (content.includes('gan') || content.includes('vae') || content.includes('diffusion') || 
            content.includes('generative') || content.includes('dcgan') || content.includes('cyclegan')) {
            tags.push('generative');
            console.log(`  ‚úÖ Added Generative tag`);
        }
        
        // Sequential Models
        if (content.includes('lstm') || content.includes('gru') || content.includes('rnn') || 
            content.includes('sequence') || content.includes('sequential')) {
            tags.push('sequential');
            console.log(`  ‚úÖ Added Sequential tag`);
        }
        
        // Attention Models
        if (content.includes('attention') || content.includes('transformer') || content.includes('bert') ||
            content.includes('self-attention')) {
            tags.push('attention');
            console.log(`  ‚úÖ Added Attention tag`);
        }
        
        // Optimization/Training
        if (content.includes('ddp') || content.includes('distributed') || content.includes('training') ||
            content.includes('optimization') || content.includes('fine') || content.includes('tune')) {
            tags.push('optimization');
            console.log(`  ‚úÖ Added Optimization tag`);
        }
        
        console.log(`üè∑Ô∏è Final tags for ${model.name}: [${tags.join(', ')}]`);
        return tags;
    }
    
    function refreshModelData() {
        console.log("üîÑ Starting refreshModelData...");
        
        // Re-read all model data including the new tags
        allModels = [];
        document.querySelectorAll('.model-wrapper').forEach((wrapper, index) => {
            const nameElement = wrapper.querySelector('.model-card__title');
            const descElement = wrapper.querySelector('.model-card__excerpt');
            
            const name = nameElement?.textContent || `Model ${index + 1}`;
            const description = descElement?.textContent || '';
            
            const model = {
                element: wrapper,
                name: name.toLowerCase(),
                description: description.toLowerCase()
            };
            
            // Generate auto tags for this model
            const autoTags = generateAutoTags(model);
            model.tags = autoTags;
            
            console.log(`  üìù Model "${name}" processed with tags: [${autoTags.join(', ')}]`);
            
            allModels.push(model);
        });
        
        console.log(`üîÑ Refreshed model data: ${allModels.length} models with auto-generated tags`);
        console.log('üìä Sample model data:', allModels.slice(0, 2));
    }
});
</script>
